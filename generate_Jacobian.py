import numpy as np

def generate_Jacobian(J_dS_dVm,J_dS_dTheta,pv_index,pq_index):
    """
    Assembles the Jacobian matrix in a right way so it matches the structure of the mismatch vector generated in
    calculate_F() The function uses the derivatives which are generated by calling the generate_Derivatives()

    returns:
        J (np.array) - Jacobian matrix
    
    args:
        J_dS_dVm (np.array) - dS/dVm
        J_dS_dTheta (np.array) - dS/dÎ¸
        pv_index (np.array) - PV bus indices
        pq_index (np.array) - PQ bus indices
    """

    # Append PV and PQ indices for convenience
    pvpq_ind = np.append(pv_index, pq_index)

    # Create the sub-matrices
    J_11 = np.real(J_dS_dTheta[np.ix_(pvpq_ind, pvpq_ind)])
    J_12 = np.real(J_dS_dVm[np.ix_(pvpq_ind, pq_index)])
    J_21 = np.imag(J_dS_dTheta[np.ix_(pq_index, pvpq_ind)])
    J_22 = np.imag(J_dS_dVm[np.ix_(pq_index, pq_index)])

    # Assemble the Jacobian matrix
    J = np.block([[J_11,J_12],[J_21,J_22]])
    
    return J 